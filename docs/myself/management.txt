技术管理者，就是让开发人员开发得爽、让团队更高效、让系统的坑更少。好多项目的通病就是图快，快快快，结果前期基础没打好，到中后期全是大坑，反而适得其反。作为技术管理者，在项目启动前应制定开发规范，明确应该怎么做、不应该怎么做；在项目前期应该将公共的工具类、公用业务逻辑该封装的封装；开发过程中仔细审查开发人员的代码，问题及时发现、及时纠正。举几个例子：

开发规范：我在开发之前的一个项目时，曾明确告诉前端开发工程师，我会在接口返回内容的最外层统一封装一层，字段有status代表状态、message代表信息和data返回数据。你也封装出来个函数统一处理最外层，定义个回调函数，status返回1时代表成功，你就调这个回调函数，把data传递给回调函数，让回调函数处理data里面的数据；返回0时代表session超时，跳登录页；返回其他状态直接提示message字段的信息就完了。针对具体调接口，就调封装过的这个函数，定制回调函数就OK了。但是前端开发没经验还不听我的，不按我的规范来，所有接口都按成功状态处理的，结果到测试时有一次在页面上怎么点都没反应，让我帮忙看是什么问题，我说“那status返回的是0，都session超时了，你应该跳到登录页了！！！你以前做的系统都是正常状态，没有session超时哈？？？”。最后费了好大劲一点一点改过来的。

各自为战：
比如张三要调个其他系统的HTTP接口，自己封装了个调HTTP接口的工具类，感觉自己用着挺爽。后来李四开发的模块中也需要调个HTTP接口，但李四不知道张三已经封装了调HTTP接口的工具类，就自己又双封装了个HTTP工具类，结果导致同一项目好多个HTTP工具类，接手项目的开发人员想要维护都不知道该用哪个。

还有个例子就是，同一业务逻辑，想要复用时本应封装一下再调，但往往没经验的程序猿图省事，直接copy-paste，同一段代码paste了好多处，如果需要改动时，往往会改漏了一两处，导致bug的出现。我参与过的项目就曾经历过这种事，导致用户账上余额多了42万，好在用户没提现，能挽回。

在管理后来的项目中我要求在手动开发之前必须把该封装的都封装好，不允许再出现类似的情况。

再举3个我曾遇到过的，号称有夺少夺少年工作经验的程序猿干的奇葩事：
1. 有个算手续费、扣手续费的功能。算出手续费在前端页面展示，到扣手续费时，将手续费的数字从前端页面向服务端传递，服务端直接用前端传递过来的这个数进行扣费。我说“人家用户要是用个什么firebug或postman之类的工具把手续费字段改成0，你不一分钱也扣不着么？？？像这种情况一定要在服务端重算！！！”
2. 分页查询，把所有数据都吐到前端，再分页，我说“你这数据量都不用太多，就几千条，浏览器就得卡死一动不动了”。
3. 还有一次我接手个项目，是另外一公司的系统调我们系统的webservice接口推送数据的。问题是数据天天有出入对不上，之前负责这项目的程序猿把这个项目甩给我，让我天天跟着对数据，一开会时就号称“成天跟他们对数据都烦死了，都是他们那边的问题，我这边一点问题没有！”。当我接手项目时什么报错信息都没有，查看代码时发现try-catch块的catch块里面什么也没干，我就在catch块里面把异常堆栈打出来，这下算是能看到报错了，发现经常抛connection closed异常，就纳闷了，后来发现这2货的Connection对象不是从pool里获取的，是创建的最原生的Connection对象给定义成static了，结果人家那边不是单线程调的，是多线程调的，这边第一个线程在处理结束后在finally块里把Connection给关了，其他线程就大量抛这个异常。

版本管理：
1. 下次不上线的功能一定要在新的分支上做开发，一定要经常性的pull主干的代码，如果出现冲突及时处理，如果不经常性的pull，到最后冲突多了处理起来会吐血；
2. 在每次发版上线后，第一时间要将当前版本git checkout -b出来一个快照分支。因为有会有这2种情况发生: 
	1. 发了新版上线后发现有问题，需要撤回到上一版本，但master已经提交了新的代码，想要恢复上一版本基本不太可能了。如果当时创建出来快照分支，想要撤回时就可以checkout到上一版本的branch，重新构建、重启就可以了；
	2. 线上抛了异常了，明明知道是哪一行代码抛的，但由于没有快照分支，并且master上已经提交了新功能的代码，要想定位这一行代码只能去查找历史记录，如果有快照分支，就可以轻松定位问题。

以上这些，都是作为技术管理者或负责人应该把握的。
